---
layout:     post   
title:      Java进程间的通信   
subtitle:   进程通信   
date:       2021-10-15   
author:     AnAn   
header-img: /img/life-bg/nature1.jpeg   
catalog: true   
tags:   
    - Java
    - 操作系统     
---   

## 介绍   

- 进程间的通信在许多科技论坛的帖子上都已经说的很详细，主要有：共享内存，管道，信号量，信号，socket等通信方式
- 但题主又觉得他们说的不够详细，在什么场景下使用，如何使用，这是许多帖子没有说清楚的

### 目录
- [共享内存](#共享内存)
- [共享内存](#共享内存)
- [管道](#管道)
- [信号量](#信号量)
- [信号](#信号)
- [socket](#socket)


<a name="共享内存"></a>
### 共享内存  
  ![processMsg](/img/post/processMsg/2021-10-18_14-47.png)  
  
- 说明  
  1. java中没有专门的共享内存方法。 MappedByteBuffer 是为了文件映射，加快大文件读写速度。
  共享内存，有许多种实现方法，在java中可以使用文件映射来实现共享内存，缺点是文件映射必须有文件，
  同时有其他开销。 文件映射的方式读写文件其实是对内存的操作，所以速度与读写内存是一致的，
  多余的开销在内存数据还是会同步到硬盘的，这个开销是异步的，影响不大。
  2. MappedByteBuffer其实是利用了操作系统底层的虚拟内存技术，将需要的磁盘文件(空间)，映射到内存中，
  内存与磁盘的同步由操作系统负责，所以这种技术下，数据在多个进程之间有一定的同步延迟。

- 特点
  1. 可被多个进程打开访问；
  2. 读写操作的进程在执行读写操作时，其他进程不能进行写操作；
  3. 多个进程可以交替对某一共享内存执行写操作；
  4. 一个进程执行内存写操作后，不影响其他进程对该内存的访问，同时其他进程对更新后的内存具有可见性；
  5. **说明** 的言外之意是MappedByteBuffer并不能保证多个进程共享内存的**强一致性**
  6. 不要经常调用MappedByteBuffer.force()方法，这个方法强制操作系统将内存中的内容写入硬盘，
  所以如果你在每次写内存映射文件后都调用force()(同步刷磁盘)方法，你就不能真正从内存映射文件中获益，
  而是跟disk IO差不多

- 共享内存管理类MemShared.class 
  ```java
  import java.io.File;
  import java.io.IOException;
  import java.io.RandomAccessFile;
  import java.nio.ByteBuffer;
  import java.nio.MappedByteBuffer;
  import java.nio.channels.FileChannel;
  import java.nio.channels.FileLock;
  
  public class MemShared {
      //第0-3个字节控制版本
      // 4-7个字节为size，表示内存可写大小
      // 第8-11个字节为position 当前读取内存获取写内存的位置
      // 第12-15个字节为limit 当前内存最大可读取位置
      // 以后为数据控制
      //createMem(File file,int size)用于初始化共享内存，对应主要方法为initSharedMem()
      //getMem(File file)用于加载已经初始化共享内存，对应主要方法为setSharedMem()
      private MemShared(){
      }
      private File file;
      private RandomAccessFile randomAccessFile;
      private FileChannel fc;
      private int off=16;//数据偏移量
      private MappedByteBuffer map;//实际的操作内存
  
      public File getFile() {
          return file;
      }
  
      public static int byteArrayToInt(byte[] bytes) {//字节转int
          int value=0;
          //由高位到低位
          for (int i = 0; i < bytes.length; i++) {
              value |= bytes[i];
              if(i<bytes.length-1)
              value <<= 8;//往高位游
          }
  
          return value;
      }
  
      public int getSize() {
          byte[] bytes = new byte[4];
          for (int i = 4; i <= 7; i++) {
              bytes[i-4]=this.map.get(i);
          }
          return byteArrayToInt(bytes);
      }
      public void setSize(int size) {
          for (int i = 7; i >= 4; i--) {
              int val = size & 0xFF;
              this.map.put(i,(byte)val);
              size>>=8;
          }
      }
  
      public int getLimit(){
          byte[] bytes = new byte[4];
          for (int i = 12; i <= 15; i++) {
              bytes[i-12]=this.map.get(i);
          }
          return byteArrayToInt(bytes);
      }
      public void setLimit(int limit){
          for (int i = 15; i >= 12; i--) {
              int val = limit & 0xFF;
              this.map.put(i,(byte)val);
              limit>>=8;
          }
      }
  
      public int getVersion() {
          byte[] bytes = new byte[4];
          for (int i = 0; i <= 3; i++) {
              bytes[i]=this.map.get(i);
          }
          return byteArrayToInt(bytes);
      }
      private void setVersion(int version){
          for (int i = 3; i >= 0; i--) {
              int val = version & 0xFF;
              this.map.put(i,(byte)val);
              version>>=8;
          }
      }
  
  
      public int getPosition(){
          byte[] bytes = new byte[4];
          for (int i = 8; i <=11; i++) {
              bytes[i-8]=this.map.get(i);
          }
          return byteArrayToInt(bytes);
      }
      public void setPosition(int position){
          for (int i = 11; i >= 8; i--) {
              int val = position & 0xFF;
              this.map.put(i,(byte)val);
              position>>=8;
          }
      }
      static MemShared createMem(File file,int size,int version) throws IOException {
          MemShared memShared = new MemShared();
          memShared.file=file;
          memShared.initSharedMem(size,version);
          return memShared;
  
      }
      static MemShared createMem(File file,int size) throws IOException {
          return createMem(file,size,0);
  
      }
  
      static MemShared getMem(File file) throws IOException {
          MemShared memShared = new MemShared();
          memShared.file=file;
          memShared.setSharedMem();
          return memShared;
      }
  
      private void setSharedMem() throws IOException {
          //获取随机存取文件对象，建立文件和内存的映射，即时双向同步
          this.randomAccessFile=new RandomAccessFile(file,"rw");
          this.fc = this.randomAccessFile.getChannel();
          byte[] bytes = new byte[4];
          this.fc.read(ByteBuffer.wrap(bytes),4);
          int size=byteArrayToInt(bytes);
          this.map = fc.map(FileChannel.MapMode.READ_WRITE, 0, size);
  
  
      }
      private void initSharedMem(int size,int version) throws IOException {
          //获取随机存取文件对象，建立文件和内存的映射，即时双向同步
          this.randomAccessFile=new RandomAccessFile(file,"rw");
          this.fc = this.randomAccessFile.getChannel();
          this.map = this.fc.map(FileChannel.MapMode.READ_WRITE, 0, this.off+size);
          this.map.put((byte) 0);
          this.setVersion(version);
          this.setPosition(0);
          this.setSize(size);
      }
      public void flip(){
          this.setPosition(0);
      }
      public void write(byte[] bytes) throws Exception {
          FileLock lock = fc.lock();
          if (bytes.length>getSize())
              throw new Exception("bytes.length>getSize()");
          this.map.put(bytes);
          this.setLimit(bytes.length);
          lock.release();
      }
      public void write(byte b) throws Exception {
          FileLock lock = fc.lock();
          int position = getPosition();
          if (position>=getSize()-1)
              throw new Exception("positoin超出内存大小");
          this.map.put(++position+this.off,b);
          this.setPosition(position);
          lock.release();
      }
      public byte get(int position) throws Exception {
          if (position>=getLimit())throw new Exception("position>=getLimit()");
          return this.map.get(position+this.off);
      }
      public byte get(){
          return this.map.get(getPosition()+this.off);
      }
      public void getBytes(byte[] bytes){
           this.map.get(bytes);
      }
  }
  ```  
- 共享内存创建NIOWrite.class 
  ```java
  import java.io.File;
  
  public class NIOWrite {
      public static void main(String[] args) throws Exception {
          File file = new File("/home/wangwen/Memshared");
          MemShared mem = MemShared.createMem(file, 2048);
          int cur=0;
          for (int i = 0; i < 10; i++) {
              mem.write((byte) cur);
              int position = mem.getPosition();
              byte b = mem.get(position);
              System.out.println("index:"+position+" "+b);
              cur=b+1;
              Thread.sleep(1000);
          }
  
      }
  }
  /*结果
  index:1 0
  index:2 1
  index:3 2
  index:4 3
  index:5 4
  index:7 5
  index:9 6
  index:11 7
  index:13 8
  index:15 9*/
  ```  
- 共享内存读取NIORead.class 
  ```java
  import java.io.File;
  
  public class NIORead {
      public static void main(String[] args) throws Exception {
          File file = new File("/home/wangwen/Memshared");
          MemShared mem = MemShared.getMem(file);
          int cur;
          for (int i = 0; i < 10; i++) {
              int position = mem.getPosition();
              byte b = mem.get(position);
              System.out.println("index:"+position+" "+b);
              cur=b+1;
              mem.write((byte) cur);
              Thread.sleep(1000);
          }
      }
  }
  /*结果
  index:5 4
  index:7 5
  index:9 6
  index:11 7
  index:13 8
  index:15 9
  index:16 10
  index:17 11
  index:18 12
  index:19 13
  */
  ```  
- 备注
  先运行NIOWrite.class，再运行NIORead.class  
  
<a name="管道"></a>
### 管道


<a name="信号量"></a>
### 信号量


<a name="信号"></a>
### 信号


<a name="socket"></a>
### socket

